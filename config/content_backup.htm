<h1>Introduction</h1>
<p>Github:  <a href="https://github.com/40823111/cd2021">許耀中的Github</a></p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="en">Website:<a href="https://40823111.github.io/cd2021/.">許耀中的</a></span><a href="https://40823111.github.io/cd2021/."><span lang="en">Website</span></a></pre>
<p><br/><br/>Youtube:<a href="https://studio.youtube.com/channel/UCDwHWerqlhllVN1FmKCBYJg/videos/upload?filter=%5B%5D&amp;sort=%7B%22columnType%22%3A%22date%22%2C%22sortOrder%22%3A%22DESCENDING%22%7D">許耀中的Youtube</a><br/><br/>Stage1<br/><br/>分組倉儲: <a href="https://40823111.github.io/stage1-ag6/content/index.html">stage1 ag6</a></p>
<p><span>Stage2</span></p>
<p><span><span>分組倉儲: <a href="https://40823111.github.io/stage2-ag6/content/index.html">stage2 ag6</a></span></span></p>
<p>Stage3</p>
<p><br/><span>分組倉儲: <a href="https://40823111.github.io/stage3-ag5/">stage3 ag5</a></span><br/><br/><span lang="en"></span></p>
<p></p>
<h1>leo</h1>
<h2>edit blog</h2>
<p>一開始你的leo是黑色的， 如果你想換成白色的</p>
<p>step1. 到File裡的 Open-Outline</p>
<p><img alt="" height="494" src="/images/螢幕擷取畫面 2021-03-08 001936.png" width="317"/></p>
<p>Step2.進到你的tmp<span>→cd2021→config</span></p>
<p><img alt="" height="350" src="/images/1615134022081.jpg" width="554"/></p>
<p>Step3. touch pelican.leo</p>
<p><img alt="" height="347" src="/images/1615134032445.jpg" width="553"/></p>
<p></p>
<p>新建disqus</p>
<p><img alt="" height="549" src="/images/1615132385371.jpg" width="560"/></p>
<p></p>
<p>改設定到遠端的pelican 劃紅線的是需要改的設定  discqus sitename 填你新建disqus的名字(Webside name)</p>
<p><img alt="" height="313" src="/images/1615133741671.jpg" width="563"/></p>
<p>指令 @others 就是可以當編輯這個網頁要編輯下一張的時候，下一張的開頭位置會是你上一張結尾的後面</p>
<p>可以繼續編排不會亂</p>
<p></p>
<h2>edit Reveal</h2>
<p>1.先進入Leo</p>
<p><img alt="" height="282" src="/images/1615380265464.jpg" width="562"/></p>
<p>2.到cd2021<span>➝config</span></p>
<p><img alt="" height="356" src="/images/1615134022081.jpg" width="564"/></p>
<p>3.選擇下面的reveal.leo</p>
<p><img alt="" height="347" src="/images/1615380359702.jpg" width="561"/></p>
<p>4.就可以開始編輯了</p>
<p><img alt="" height="382" src="/images/1615380702356.jpg" width="562"/></p>
<h1>old repositories update</h1>
<p>1.因為舊的repositiors和更新版只差7個更新檔案，所以只需要git pull 更新檔案就好、所以</p>
<p>Step1.到你的cmsimde <span>→ </span>git pull origin master</p>
<p><img alt="" height="292" src="/images/1.jpg" width="560"/></p>
<p>Step2.他就會顯示已經download 7個檔案</p>
<p><img alt="" height="291" src="/images/2.jpg" width="560"/></p>
<p>檔案說明:</p>
<ol>
<li><span>init.py</span><span> </span>- 其中的 site_title, ip 與 port 可以讓使用者自行修改, site_title 是網站標題, ip 為動態網站啟動時所使用的網路位址, 可設為內部或外部 IPv4 (IPv6), port 則是動態網站啟動時所佔用的埠號.</li>
<li><span>http-server.py</span><span> </span>- 執行後會使用內建的 localhost 與 port 8444 伺服 content 子目錄中的 CMSiMDE 靜態網頁.</li>
<li><span>cms.bat</span><span> </span>- 讓使用者執行動態網站用的批次檔案.</li>
<li><span>acp.bat</span><span> </span>- 若使用者已經將倉儲設為 ssh 連線, 且提供遠端與近端的認證模式, 則可以在執行此批次指令之後加上提交字串, 即可執行 git add ., git commit -m "提交訊息", 以及 git push 等三個指令.</li>
</ol>
<p></p>
<p>Step3. 到你的 updir 把你的更新檔複製到你的cd2021<span>→ complete→ 以後你的工作都在cd2021</span></p>
<p><img alt="" height="575" src="/images/3.jpg" width="563"/></p>
<p>Step4.</p>
<p>以後要開cmsimde(到你的cd2021)=cms(動態就會自己開)</p>
<p><span>以後要開上傳(到你的cd2021)=acp </span></p>
<h1>repositories create</h1>
<p><span>notice: 因為cmsimde改版 所以設定全部更新</span></p>
<p><span>(1)system <a href="https://github.com/mdecourse/cd2021/discussions/7">cd2021可攜系統 </a></span></p>
<p><span>(2)download  <a href="https://drive.google.com/file/d/1R6vAAWdNDigmyvFFQTKyM-XNKOWeCFJU/view">kmol2021 spring  v2.7z</a></span></p>
<p><span>(3) 改 gitconfig</span><span> </span></p>
<p><strong><strong style="font-style: italic;"> </strong></strong></p>
<p><span><img alt="" height="447" src="/images/1615443540301.jpg" width="567"/></span></p>
<p><span><img alt="" height="747" src="/images/1615443508822.jpg" width="563"/></span></p>
<p><span></span></p>
<p>(4)Repository:<span> </span><a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></p>
<p>  利用 cmstemplate 建立以 CMSiMDE 作為子模組的動態與靜態網站方法為:</p>
<ol>
<li>登入 Github 帳號</li>
<li>將瀏覽器指向<span> </span><a href="https://github.com/mdecourse/cmstemplate">https://github.com/mdecourse/cmstemplate</a></li>
</ol>
<p><img alt="" height="308" src="/images/1615446445939.jpg" width="563"/></p>
<p><span> (5) inside the page 填寫資料</span></p>
<p><span><img alt="" height="254" src="/images/1615379419301.jpg" width="569"/></span></p>
<p><span>(6) 打指令 git clone --recurse-submodules https://github.com/40823111/cd2021.git</span></p>
<p><span><img alt="" height="289" src="/images/1615441848121.jpg" width="555"/></span></p>
<p>(7)進入 cd2021<span>→cmsimde→up_dir(裡面有5個檔案)</span></p>
<p><img alt="" height="477" src="/images/螢幕擷取畫面 2021-03-11 152457.png" width="560"/></p>
<p></p>
<p>(7) 完成後 就可以git push</p>
<p>acp.bat 內容</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">echo off
set message=%1
git add .
git commit -m %message%
git push</pre>
<p><img alt="" height="288" src="/images/螢幕擷取畫面 2.png" width="554"/></p>
<p><span></span></p>
<p></p>
<h1>stage1</h1>
<h2>week1</h2>
<p>第一階段分組協同實習:</p>
<p>每週分組報告必須包含 html, pdf 與 Youtube 影片:</p>
<p>標題:<span> </span><span>2021-協同產品設計實習-stage1-ag1</span></p>
<p>專題題目:</p>
<p>第一位組員學號:40823111</p>
<p>第二位組員學號:40823139</p>
<p></p>
<p></p>
<p>交付給各組的實習任務:</p>
<ol>
<li><span>請在各組組長的 Github 帳號下建立各組的分組網站, 惟在 W1 進行各班定組序過程中, 發現即便採用 Ethercalc 以網際協同方式同步讓各班自選組員填入兩兩成組的學員學號, 但仍缺人工或自動定各班組序的有效方案, 在此責成各組在進行自選的協同產品開發項目之際 (W2-W4), 將此議題列為必選的題目之一, 詳細說明各組認為最有效率的第一階段與訂定組序的方法及流程.</span></li>
<li><span>此外, 為了讓各組在 stage1 分組協同實習過程, 能透過網誌發表各組組員在 W2-W4 過程中的各項作為與心得報告, 說明可利用 Leo Editor 協助 CMSiMDE 中的 Pelican 發表協同網誌, 其目的是讓各分組在協同期間, 能完整呈現各階段所留下的網誌紀錄. 但此方式必須熟悉 Leo Editor 的操作, 因此有關透過 Pelican 建立協同網誌一事, 除利用 Leo Editor 協助設定並建立 pelican 網誌外, 也將此議題列為各組在 Stage1 協同產品設計流程中必選題目之二, 請各組詳細說明採用或不採用 Leo Editor 的兩種情況下, 各組員在設定與建立協同網誌的過程所可能遭遇或產生的問題與解決方案.</span></li>
</ol>
<h2>week2</h2>
<p>我們的主題 及 進度說明</p>
<p><span>題目:套圈遊樂器</span><br/><span>動機:經常於夜市中看到的套圈圈，於軟體中進行模擬與參數調整，對其分析統整，求得各類結果</span><br/><span>第二周:零件創建與機構改善</span><br/><span>第三周:軟體模擬與程式編輯</span><br/><span>第四周:統整結果與報告內容</span></p>
<p><span></span></p>
<p><span>這是把圈圈送到上面的運輸機構</span></p>
<p><img alt="" height="380" src="/images/1615381525022.jpg" width="566"/></p>
<h2>week3</h2>
<h4>機構 程式</h4>
<p>1.機構完成 運送機構改善配合及組裝(inventor 組合圖)</p>
<p><img alt="" height="400" src="/images/1615645697398.jpg" width="558"/></p>
<p> 各種零件檔</p>
<p>2.程式模擬(測試爪子的路徑和抓的力道)</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/fbIq6b8Xybo" width="560"></iframe></p>
<h4>改良</h4>
<p>1.因為前面設計的機構太過理想，雖然在inventor上可以模擬，但是到CoppeliaSim由於干涉太多及運動過程中會有震動，導致圈圈沒辦法正常運送</p>
<p></p>
<h2>week4</h2>
<p>1.工程圖</p>
<p><img alt="" height="402" src="/images/Inventor_9Oy4NiufCt.png" width="571"/></p>
<p></p>
<p>2.爆炸圖</p>
<p><img alt="" height="394" src="/images/Inventor_7MZQCBKZ7G.png" width="568"/></p>
<p></p>
<p>3.完成品</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/md3fNab1UXo" width="560"></iframe></p>
<h1>stage2</h1>
<h2>week5</h2>
<p>step2 題目 : 自動打球機及手動接球</p>
<p>設計 自動送球機構 及 接球手套 機械手臂打球(打者) 和 手動機械手臂接球(防守者)</p>
<h2>week6</h2>
<h4>設計理想</h4>
<ol>
<li>一個平台(棒球場) 球打出去後可以接球(防守者) 漏接的球可以自動流回輸送台，再次被送回來</li>
<li>使用類似螺紋的概念把球輸送到想要的平台</li>
<li>希望可以把球的軌跡沿著螺旋線上升</li>
<li>做成一個循迴機構</li>
</ol>
<h4>創建協同</h4>
<p>step1 組長創一個創一個respoitory    組員創一個和組長一模一樣的<span>respoitory的名子</span></p>
<p><span>step2 在github裡new respoitory 互相邀請 </span></p>
<p>step3 組長 git clone --recurse-submodules https://github.com/40823111/cd2021.git</p>
<p><img alt="" height="296" src="/images/1615441848121.jpg" width="567"/></p>
<p>step3  git remote add 組員的學號 https://github.com/<span>組員的學號</span>/stage2-ag6.git</p>
<p>          組長授權給組員</p>
<p>流程示意圖</p>
<p><img alt="" height="426" src="/images/222.jpg" width="567"/></p>
<h2>week7</h2>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/Y33taPcSXP0" title="YouTube video player" width="560"></iframe></p>
<p>模擬失敗 </p>
<p> 問題 1. 因為我們是設計螺旋線的上升機構， 所以到輸送平台時把它用直線，導致不符合公差尺寸而跑掉</p>
<p> 解決1. <span>改善後 把它改成符合螺旋線的入口</span></p>
<p><img alt="" height="425" src="/images/44085.jpg" width="239"/>   <img alt="" height="239" src="/images/messageImage_1618473034644.jpg" width="302"/></p>
<h4>CoppeliaSim模擬與運送機構創建</h4>
<p>整體運用重點:</p>
<ol>
<li>向本週主軸:CoppeliaSim模擬與運送機構創建</li>
</ol>
<p>整體運用重點:</p>
<ol>
<li>IK逆運動學</li>
<li>正向運動學</li>
<li>送球機構創建</li>
</ol>
<p>本週問題:</p>
<ol>
<li>多軸手臂的運動預測</li>
<li>送球機構創建未果</li>
<li>球受力後的運動路徑預測</li>
</ol>
<p>問題改善:</p>
<ol>
<li>藉由DH法做運動預期</li>
<li>加入運動學運算</li>
</ol>
<h2>week8</h2>
<h4>送球機構</h4>
<p>問題1 : <span>球進不去 只能靠後面球的推力才可以勉強塞進去</span></p>
<p></p>
<p></p>
<p></p>
<p><span>問題2. 球進去後機構也沒辦法把球推上去 因為斜角太斜導致球會網協度相對小的地方(入口)滾動</span></p>
<p><span></span></p>
<p><span></span></p>
<p><span></span></p>
<p><span></span></p>
<p><span></span></p>
<p><span>改善: 斜度改小 把凹槽加長 使凹槽和倒角之間有一個倒三角形可以讓球跑到裡面卡住 不會往後滾</span></p>
<h2>week9</h2>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/pLdbxNwan2k" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/123/final.ttt">棒球模擬機.ttt</a></p>
<h1>stage3</h1>
<h2>week10</h2>
<h3>task1</h3>
<p><span>讀取 stage3_2a.txt, 建立 Stage3 的分組倉儲, 分組網頁, 以及各組員倉儲及網頁連結</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/9d4o_kNielU" title="YouTube video player" width="560"></iframe></p>
<p><span></span></p>
<p><span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">with open("stage3_2a.txt") as gp:
    # readlines will read into the whole line and put into list format
    # has \n at the end of each line
    data = gp.readlines()
    data = [d.replace('4823122','40823122') for d in data]
    data = [v.replace('\t\t\t\t','') for v in data]
#print(len(data))
for p in range(len(data)):
    group = data[p].rstrip("\n").split("\t")
    print('&lt;p&gt;'+group[0]+' | &lt;a href="https://'+group[1]+'.github.io/stage3-ag'+group[0][9]+'"&gt;網站&lt;/a&gt;  &lt;a href="https://github.com/'+group[2]+'/stage3-ag'+group[0][9]+'"&gt;倉儲&lt;/a&gt;&lt;/p&gt;')
    for  q in range(2,18,2):
        try:
              print('&lt;p&gt;'+group[q]+' | Website:'+'&lt;a href="https://'+group[q]+'.github.io/cd2021'+'"&gt;'+group[q]+'&lt;/a&gt;'+' | Repository:'+'&lt;a href="https://github.com/'+group[q]+'/cd2021'+'"&gt;'+group[q]+'&lt;/a&gt;'+' | Group Website:'+'&lt;a href="https://'+group[q]+'.github.io/stage3-ag'+group[0][9]+'"&gt;'+group[q]+'&lt;/a&gt;&lt;/p&gt;' )
        except:
            continue</pre>
<p></p>
<p></p>
<p>stage3_ag1 | <a href="https://40823131.github.io/stage3-ag1">網站</a> <a href="https://github.com/40823131/stage3-ag1">倉儲</a></p>
<p>40823131 | Website:<a href="https://40823131.github.io/cd2021">40823131</a> | Repository:<a href="https://github.com/40823131/cd2021">40823131</a> | Group Website:<a href="https://40823131.github.io/stage3-ag1">40823131</a></p>
<p>a40823112 | Website:<a href="https://a40823112.github.io/cd2021">a40823112</a> | Repository:<a href="https://github.com/a40823112/cd2021">a40823112</a> | Group Website:<a href="https://a40823112.github.io/stage3-ag1">a40823112</a></p>
<p>40823123 | Website:<a href="https://40823123.github.io/cd2021">40823123</a> | Repository:<a href="https://github.com/40823123/cd2021">40823123</a> | Group Website:<a href="https://40823123.github.io/stage3-ag1">40823123</a></p>
<p>40823145 | Website:<a href="https://40823145.github.io/cd2021">40823145</a> | Repository:<a href="https://github.com/40823145/cd2021">40823145</a> | Group Website:<a href="https://40823145.github.io/stage3-ag1">40823145</a></p>
<p>40823136 | Website:<a href="https://40823136.github.io/cd2021">40823136</a> | Repository:<a href="https://github.com/40823136/cd2021">40823136</a> | Group Website:<a href="https://40823136.github.io/stage3-ag1">40823136</a></p>
<p>40823109 | Website:<a href="https://40823109.github.io/cd2021">40823109</a> | Repository:<a href="https://github.com/40823109/cd2021">40823109</a> | Group Website:<a href="https://40823109.github.io/stage3-ag1">40823109</a></p>
<p>40823116 | Website:<a href="https://40823116.github.io/cd2021">40823116</a> | Repository:<a href="https://github.com/40823116/cd2021">40823116</a> | Group Website:<a href="https://40823116.github.io/stage3-ag1">40823116</a></p>
<p>40823108 | Website:<a href="https://40823108.github.io/cd2021">40823108</a> | Repository:<a href="https://github.com/40823108/cd2021">40823108</a> | Group Website:<a href="https://40823108.github.io/stage3-ag1">40823108</a></p>
<p>stage3_ag2 | <a href="https://40823151.github.io/stage3-ag2">網站</a> <a href="https://github.com/40823151/stage3-ag2">倉儲</a></p>
<p>40823151 | Website:<a href="https://40823151.github.io/cd2021">40823151</a> | Repository:<a href="https://github.com/40823151/cd2021">40823151</a> | Group Website:<a href="https://40823151.github.io/stage3-ag2">40823151</a></p>
<p>40623121 | Website:<a href="https://40623121.github.io/cd2021">40623121</a> | Repository:<a href="https://github.com/40623121/cd2021">40623121</a> | Group Website:<a href="https://40623121.github.io/stage3-ag2">40623121</a></p>
<p>40871106 | Website:<a href="https://40871106.github.io/cd2021">40871106</a> | Repository:<a href="https://github.com/40871106/cd2021">40871106</a> | Group Website:<a href="https://40871106.github.io/stage3-ag2">40871106</a></p>
<p>40823102 | Website:<a href="https://40823102.github.io/cd2021">40823102</a> | Repository:<a href="https://github.com/40823102/cd2021">40823102</a> | Group Website:<a href="https://40823102.github.io/stage3-ag2">40823102</a></p>
<p>40823104 | Website:<a href="https://40823104.github.io/cd2021">40823104</a> | Repository:<a href="https://github.com/40823104/cd2021">40823104</a> | Group Website:<a href="https://40823104.github.io/stage3-ag2">40823104</a></p>
<p>40823106 | Website:<a href="https://40823106.github.io/cd2021">40823106</a> | Repository:<a href="https://github.com/40823106/cd2021">40823106</a> | Group Website:<a href="https://40823106.github.io/stage3-ag2">40823106</a></p>
<p>40823101 | Website:<a href="https://40823101.github.io/cd2021">40823101</a> | Repository:<a href="https://github.com/40823101/cd2021">40823101</a> | Group Website:<a href="https://40823101.github.io/stage3-ag2">40823101</a></p>
<p>40823132 | Website:<a href="https://40823132.github.io/cd2021">40823132</a> | Repository:<a href="https://github.com/40823132/cd2021">40823132</a> | Group Website:<a href="https://40823132.github.io/stage3-ag2">40823132</a></p>
<p>stage3_ag3 | <a href="https://40823119.github.io/stage3-ag3">網站</a> <a href="https://github.com/40823119/stage3-ag3">倉儲</a></p>
<p>40823119 | Website:<a href="https://40823119.github.io/cd2021">40823119</a> | Repository:<a href="https://github.com/40823119/cd2021">40823119</a> | Group Website:<a href="https://40823119.github.io/stage3-ag3">40823119</a></p>
<p>40823150 | Website:<a href="https://40823150.github.io/cd2021">40823150</a> | Repository:<a href="https://github.com/40823150/cd2021">40823150</a> | Group Website:<a href="https://40823150.github.io/stage3-ag3">40823150</a></p>
<p>40823103 | Website:<a href="https://40823103.github.io/cd2021">40823103</a> | Repository:<a href="https://github.com/40823103/cd2021">40823103</a> | Group Website:<a href="https://40823103.github.io/stage3-ag3">40823103</a></p>
<p>40823107 | Website:<a href="https://40823107.github.io/cd2021">40823107</a> | Repository:<a href="https://github.com/40823107/cd2021">40823107</a> | Group Website:<a href="https://40823107.github.io/stage3-ag3">40823107</a></p>
<p>40523252 | Website:<a href="https://40523252.github.io/cd2021">40523252</a> | Repository:<a href="https://github.com/40523252/cd2021">40523252</a> | Group Website:<a href="https://40523252.github.io/stage3-ag3">40523252</a></p>
<p>40823154 | Website:<a href="https://40823154.github.io/cd2021">40823154</a> | Repository:<a href="https://github.com/40823154/cd2021">40823154</a> | Group Website:<a href="https://40823154.github.io/stage3-ag3">40823154</a></p>
<p>stage3_ag4 | <a href="https://40823142.github.io/stage3-ag4">網站</a> <a href="https://github.com/40823142/stage3-ag4">倉儲</a></p>
<p>40823142 | Website:<a href="https://40823142.github.io/cd2021">40823142</a> | Repository:<a href="https://github.com/40823142/cd2021">40823142</a> | Group Website:<a href="https://40823142.github.io/stage3-ag4">40823142</a></p>
<p>40823144 | Website:<a href="https://40823144.github.io/cd2021">40823144</a> | Repository:<a href="https://github.com/40823144/cd2021">40823144</a> | Group Website:<a href="https://40823144.github.io/stage3-ag4">40823144</a></p>
<p>40823127 | Website:<a href="https://40823127.github.io/cd2021">40823127</a> | Repository:<a href="https://github.com/40823127/cd2021">40823127</a> | Group Website:<a href="https://40823127.github.io/stage3-ag4">40823127</a></p>
<p>40823148 | Website:<a href="https://40823148.github.io/cd2021">40823148</a> | Repository:<a href="https://github.com/40823148/cd2021">40823148</a> | Group Website:<a href="https://40823148.github.io/stage3-ag4">40823148</a></p>
<p>40823121 | Website:<a href="https://40823121.github.io/cd2021">40823121</a> | Repository:<a href="https://github.com/40823121/cd2021">40823121</a> | Group Website:<a href="https://40823121.github.io/stage3-ag4">40823121</a></p>
<p>40823135 | Website:<a href="https://40823135.github.io/cd2021">40823135</a> | Repository:<a href="https://github.com/40823135/cd2021">40823135</a> | Group Website:<a href="https://40823135.github.io/stage3-ag4">40823135</a></p>
<p>40823114 | Website:<a href="https://40823114.github.io/cd2021">40823114</a> | Repository:<a href="https://github.com/40823114/cd2021">40823114</a> | Group Website:<a href="https://40823114.github.io/stage3-ag4">40823114</a></p>
<p>40823146 | Website:<a href="https://40823146.github.io/cd2021">40823146</a> | Repository:<a href="https://github.com/40823146/cd2021">40823146</a> | Group Website:<a href="https://40823146.github.io/stage3-ag4">40823146</a></p>
<p>stage3_ag5 | <a href="https://40823111.github.io/stage3-ag5">網站</a> <a href="https://github.com/40823111/stage3-ag5">倉儲</a></p>
<p>40823111 | Website:<a href="https://40823111.github.io/cd2021">40823111</a> | Repository:<a href="https://github.com/40823111/cd2021">40823111</a> | Group Website:<a href="https://40823111.github.io/stage3-ag5">40823111</a></p>
<p>40823115 | Website:<a href="https://40823115.github.io/cd2021">40823115</a> | Repository:<a href="https://github.com/40823115/cd2021">40823115</a> | Group Website:<a href="https://40823115.github.io/stage3-ag5">40823115</a></p>
<p>40823128 | Website:<a href="https://40823128.github.io/cd2021">40823128</a> | Repository:<a href="https://github.com/40823128/cd2021">40823128</a> | Group Website:<a href="https://40823128.github.io/stage3-ag5">40823128</a></p>
<p>40823120 | Website:<a href="https://40823120.github.io/cd2021">40823120</a> | Repository:<a href="https://github.com/40823120/cd2021">40823120</a> | Group Website:<a href="https://40823120.github.io/stage3-ag5">40823120</a></p>
<p>40823140 | Website:<a href="https://40823140.github.io/cd2021">40823140</a> | Repository:<a href="https://github.com/40823140/cd2021">40823140</a> | Group Website:<a href="https://40823140.github.io/stage3-ag5">40823140</a></p>
<p>40823124 | Website:<a href="https://40823124.github.io/cd2021">40823124</a> | Repository:<a href="https://github.com/40823124/cd2021">40823124</a> | Group Website:<a href="https://40823124.github.io/stage3-ag5">40823124</a></p>
<p>40823139 | Website:<a href="https://40823139.github.io/cd2021">40823139</a> | Repository:<a href="https://github.com/40823139/cd2021">40823139</a> | Group Website:<a href="https://40823139.github.io/stage3-ag5">40823139</a></p>
<p>40823126 | Website:<a href="https://40823126.github.io/cd2021">40823126</a> | Repository:<a href="https://github.com/40823126/cd2021">40823126</a> | Group Website:<a href="https://40823126.github.io/stage3-ag5">40823126</a></p>
<p>stage3_ag6 | <a href="https://40823152.github.io/stage3-ag6">網站</a> <a href="https://github.com/40823152/stage3-ag6">倉儲</a></p>
<p>40823152 | Website:<a href="https://40823152.github.io/cd2021">40823152</a> | Repository:<a href="https://github.com/40823152/cd2021">40823152</a> | Group Website:<a href="https://40823152.github.io/stage3-ag6">40823152</a></p>
<p>40823110 | Website:<a href="https://40823110.github.io/cd2021">40823110</a> | Repository:<a href="https://github.com/40823110/cd2021">40823110</a> | Group Website:<a href="https://40823110.github.io/stage3-ag6">40823110</a></p>
<p>40823122 | Website:<a href="https://40823122.github.io/cd2021">40823122</a> | Repository:<a href="https://github.com/40823122/cd2021">40823122</a> | Group Website:<a href="https://40823122.github.io/stage3-ag6">40823122</a></p>
<p>40823125 | Website:<a href="https://40823125.github.io/cd2021">40823125</a> | Repository:<a href="https://github.com/40823125/cd2021">40823125</a> | Group Website:<a href="https://40823125.github.io/stage3-ag6">40823125</a></p>
<p>40823117 | Website:<a href="https://40823117.github.io/cd2021">40823117</a> | Repository:<a href="https://github.com/40823117/cd2021">40823117</a> | Group Website:<a href="https://40823117.github.io/stage3-ag6">40823117</a></p>
<p>40823129 | Website:<a href="https://40823129.github.io/cd2021">40823129</a> | Repository:<a href="https://github.com/40823129/cd2021">40823129</a> | Group Website:<a href="https://40823129.github.io/stage3-ag6">40823129</a></p>
<p>40823149 | Website:<a href="https://40823149.github.io/cd2021">40823149</a> | Repository:<a href="https://github.com/40823149/cd2021">40823149</a> | Group Website:<a href="https://40823149.github.io/stage3-ag6">40823149</a></p>
<p>40823153 | Website:<a href="https://40823153.github.io/cd2021">40823153</a> | Repository:<a href="https://github.com/40823153/cd2021">40823153</a> | Group Website:<a href="https://40823153.github.io/stage3-ag6">40823153</a></p>
<p><br/><span></span></p>
<h3>task2</h3>
<p><span>採 Python remote API 進行操控</span></p>
<p><span></span></p>
<p><span>step1  </span></p>
<p><span>先把5個檔案放在同一個資料夾</span></p>
<p><span></span></p>
<p><span><img alt="" height="149" src="/images/1621441859591.jpg" width="566"/></span></p>
<p><span>step2</span></p>
<p><span>打開CoppliaSim(4.2.0)把你要的檔案丟進去  </span></p>
<p><span><img alt="" height="408" src="/images/1621441935131.jpg" width="564"/></span></p>
<p><span></span></p>
<p><span></span>step3</p>
<p><span>把程式複製放在主體的上面(如果沒有可以自己新增)</span></p>
<p><img alt="" height="418" src="/images/1621442379740.jpg" width="288"/></p>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">threadFunction=function()
	-- Put your thread code here (initialization and clean-up code should not be in here)

	
	-- Some EXTERNAL commands (e.g. socket commands provided by Lua libraries)
	-- might appear as blocking to the simulator. In that case, you can define
	-- a non-blocking section as following example shows:
	--
	-- sim.setThreadIsFree(true) -- Start of the non-blocking section
	--
	-- Following 2 lines are meant as an example of EXTERNAL blocking commands:
	-- http = require("socket.http")
	-- print(http.request("http://www.google.com"))
	--
	-- sim.setThreadIsFree(false) -- End of the non-blocking section
	--
	-- While in a non-blocking section, try to avoid calling sim-functions. Also
	-- never forget to close the blocking section, otherwise V-REP will hang.
	-- Make sure you read the information related to the sim.setThreadIsFree
	-- API function in V-REP's documentation.


	-- If you wish to synchronize a threaded loop with each simulation pass,
	-- set the thread switch timing in the initialization phase of this script
	-- to the maximum (200), and manually switch thread here with the
	-- sim.switchThread() command. 
	-- ( sim.switchThread() will suspend this script's execution until next
	-- simulation pass, i.e. until the simulation time has changed )
	--
	-- Following example illustrates this:
	-- 
	-- while true do
	--     local p=sim.getObjectPosition(objHandle,-1)
	--     p[1]=p[1]+0.001
	--     sim.setObjectPosition(objHandle,-1,p)
	--     sim.switchThread()
	-- end
end

-- Put some initialization code here:
sim.setThreadSwitchTiming(2) -- Default timing for automatic thread switching

-- Here we execute the regular thread code:
res,err=xpcall(threadFunction,function(err) return debug.traceback(err) end)
if not res then
	sim.addStatusbarMessage('Lua runtime error: '..err)
end

-- Put some clean-up code here:
simRemoteApi.start(19999)
</pre>
<h2>week11</h2>
<h3>task3</h3>
<p>影片直播</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/BaqrJgY4yKA" title="YouTube video player" width="560"></iframe></p>
<h2>week12</h2>
<h3>topic</h3>
<p>題目 </p>
<p></p>
<p>下載 RoboDK 5.2.2 及pick and place</p>
<p> <a href="https://drive.google.com/file/d/13dzUp_j6U2PBHY1Gzl_1tzxSg7ULT8qi/view?usp=sharing">下載 RoboDK 5.2.2 可攜程式</a><span><span> </span>(</span><a href="https://drive.google.com/file/d/1IhQK5TRQTBBegG2LizypdE-i39n_T7fO/view?usp=sharing">5.2.3</a><span>) - 可用於工業機械手臂離線設計與模擬</span></p>
<p><span><a href="https://drive.google.com/file/d/1XoB3F5cPK8R4Y8AIWL5pKR5TQjPW8TRv/view?usp=sharing">Pick and Place 檔案下載</a></span></p>
<p><span>開啟 Pick and Place 專案檔案後, Python 以 pip install robodk 後, 可以開啟下列控制程式, 逐一由機械手臂將球從 Table1 取放至 Table2, 圓球排列方式採 </span><a href="https://en.wikipedia.org/wiki/Square_pyramid">Square Pyramid</a><span>. 使用者可精確送出各球座標位置, 導引機械手臂取放圓球</span></p>
<p></p>
<h3>影片直播</h3>
<p>第一支</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/DxpgK7z7EH0" title="YouTube video player" width="560"></iframe></p>
<p>第二支</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/2ypzUa548uc" title="YouTube video player" width="560"></iframe></p>
<h2>week13</h2>
<h3>RoboDK</h3>
<p>機械手臂 Pick and Place Python API 程式:</p>
<p><a href="https://drive.google.com/file/d/13dzUp_j6U2PBHY1Gzl_1tzxSg7ULT8qi/view?usp=sharing">下載 RoboDK 5.2.2 可攜程式</a><span><span> </span>(</span><a href="https://drive.google.com/file/d/1IhQK5TRQTBBegG2LizypdE-i39n_T7fO/view?usp=sharing">5.2.3</a><span>) </span></p>
<p><span>完整的 </span><a href="https://drive.google.com/file/d/1XoB3F5cPK8R4Y8AIWL5pKR5TQjPW8TRv/view?usp=sharing">Pick and Place 檔案下載</a></p>
<p><a href="https://drive.google.com/file/d/1WRX6i6cA_f8ER6kN8yNwt1sdZTLMhl4J/view?usp=sharing">下載 CoppeliaSim 4.1.0 可攜程式</a><span><span> </span>(使用舊版的) </span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/sQ6QacdSuYY" title="YouTube video player" width="560"></iframe></p>
<h3>FANUC_M710iC_50 機械手臂Remote Api</h3>
<p><a href="https://drive.google.com/drive/folders/103yUZpCL7cojqVvgnAuj180KEq8Iz5rC?usp=sharing">FANUC_M710iC_50.ttt</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/5NA08LdLOWI" title="YouTube video player" width="560"></iframe></p>
<p><span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import sim as vrep
import sys
import keyboard
import math
import time
# child threaded script: 
#simExtRemoteApiStart(19999)
  
vrep.simxFinish(-1)
clientID = vrep.simxStart('127.0.0.1', 19999, True, True, 5000, 5)
errorCode,left_motor_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint',vrep.simx_opmode_oneshot_wait)
errorCode,right_motor_handle=vrep.simxGetObjectHandle(clientID,'Revolute_joint1',vrep.simx_opmode_oneshot_wait)
 
 
if clientID!= -1:
    print("Connected to remote server")
    while True: 
        try:
            if keyboard.is_pressed('up'):
                  vrep.simxSetJointTargetVelocity(clientID,left_motor_handle,-0.1, vrep.simx_opmode_oneshot_wait)
                  vrep.simxSetJointTargetVelocity(clientID,right_motor_handle,-0.1, vrep.simx_opmode_oneshot_wait)
                  print('up')
            if keyboard.is_pressed('down'):     
                  vrep.simxSetJointTargetVelocity(clientID,left_motor_handle,0.1, vrep.simx_opmode_oneshot_wait)
                  vrep.simxSetJointTargetVelocity(clientID,right_motor_handle,0.1, vrep.simx_opmode_oneshot_wait)
                  print('down')
            if keyboard.is_pressed('space'):
                  vrep.simxSetJointTargetVelocity(clientID,left_motor_handle,0 , vrep.simx_opmode_oneshot_wait)
                  print('space')
            if keyboard.is_pressed('z'):
                 vrep.simxSetJointTargetVelocity(clientID,left_motor_handle,0 , vrep.simx_opmode_oneshot_wait)
                 print('break ')
                 break
            else:
                pass
        except:
            break
else: 
    print('Connection not successful')
    sys.exit('Could not connect')
</pre>
<p><span></span></p>
<p><span></span></p>
<h2>week14</h2>
<p>創造第二個雲端 Gitlab(第二次備份)</p>
<h4>Gitlab 同步</h4>
<p>要利用 Gitlab 同步位於 Github 上的 CMSiMDE 倉儲與 Github Pages 網頁, 需要注意以下兩個要點:</p>
<ol>
<li>完成<span>   </span><span> </span>帳號申請與驗證.</li>
<li>在原先 Github 倉儲中增加一個 .gitlab-ci.yml 檔案, 目的是用來產生與倉儲對應的 Gitlab Pages 網站.</li>
</ol>
<p>step1. 申請帳號</p>
<p><img alt="" height="338" src="/images/gitlab1.jpg" width="565"/></p>
<p>step2. 設定(記得設為Private)</p>
<p></p>
<p><img alt="" height="549" src="/images/gitlab2.jpg" width="574"/></p>
<p>step3. 把github的資料推到Gitlab上面</p>
<p><img alt="" height="142" src="/images/gitlab3.jpg" width="571"/></p>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">Y:\&gt;G:

G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2&gt;cd data

G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2\data&gt;cd tmp

G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2\data\tmp&gt;cd cd2021

G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2\data\tmp\cd2021&gt;git push gitlab
</pre>
<p></p>
<h2>week15</h2>
<p></p>
<h3>part 1-joint</h3>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/IKOGwoJ2HLk" title="YouTube video player" width="560"></iframe></p>
<p>We saw this simple two-link robot in the previous lecture about forward kinematics.</p>
<p>我們在上一堂關於正向運動學的講座中看到了這個簡單的雙連桿機器人</p>
<p>The tooltip pose of this robot is discribed simply by two number ,the coordinates x and y with</p>
<p>respect to the world coordinate frame.</p>
<p>這個機器人的工具提示位姿簡單地由兩個數字來描述，坐標 x 和 y 與相對於世界坐標系。</p>
<p>So, the problem here is that given x and y, we want to determine the joined angles, Q1 and</p>
<p>Q2.  </p>
<p>所以，這裡的問題是給定 x 和 y，我們想要確定連接角 Q1 和 Q2。</p>
<p>The solution that we're going to follow in this particular section is a geometric</p>
<p>我們將在本節中遵循的解決方案是幾何</p>
<p>ONE. We're going to start with a simple piece of construction.</p>
<p>一。 我們將從一個簡單的結構開始。</p>
<p><span>We're going to overlay the red triangle on top of our robot.</span></p>
<p><span>我們將在我們的機器人頂部覆蓋紅色三角形。</span></p>
<p><span>We know that the end point coordinate is x, y, so the vertical height of the triangle is y,horizontal width is x.</span></p>
<p><span>我們知道終點坐標是x，y，所以三角形的垂直高度是y，水平寬度是x。</span></p>
<p><span>And, using Pythagoras theorem, we can write thagoras r squared equals x squared plus y squared.</span></p>
<p><span>並且，使用畢達哥拉斯定理，我們可以寫出 畢氏定理  r 平方等於 x 平方加 y 平方。</span></p>
<p><span>So far.so easy. Now, we're going to look at this triangle highlighted here in red and we want to determine the angle alpha.</span></p>
<p><span></span>到目前為止，很容易。 現在，我們將查看此處以紅色突出顯示的三角形，我們要確定角度α。</p>
<p><span>In order to do that, we need to use the cosine rule.</span></p>
<p><span>為了做到這一點，我們需要使用 cos 規則。</span></p>
<p><span>And, if you're a little rusty on the cosine rule, here is a bit of a refresher.</span></p>
<p><span>而且，如果你對 cos 規則有點生疏，這裡有一點複習。</span></p>
<p><span>We have an arbitrary triangle.</span></p>
<p>我們有一個任意三角形。</p>
<p><span>We don't have to have any right angles in it and we're going to label the length of this edge as A and the angle opposite that edge, we're going to label as little a.</span></p>
<p><span></span>我們不必在其中有任何直角，我們將這條邊的長度標記為 A，而與該邊相對的角度，我們將標記為小 a。</p>
<p><span>And, we do the same for this edge and this angle, and this edge and this angle.</span></p>
<p><span>並且，我們對這條邊和這個角，以及這條邊和這個角做同樣的事情。</span></p>
<p><span>So, all together, the sides are labelled capitals A, B and C, and the angles are labelled little a, little b, and little c.</span></p>
<p><span>因此，所有邊都標記為大寫字母 A、B 和 C，角標記為小 a、小 b 和小 c。</span></p>
<p><span>So, the cosine rule is simply this relationship here.</span></p>
<p><span>所以，cos 規則就是這裡的這種關係。</span></p>
<p><span>It's a bit like Pythagoras' theorem except for this extra term on the end with the cos a in it.</span></p>
<p><span></span>它有點像畢達哥拉斯的定理，除了最後一個額外的術語，其中有 cos a。</p>
<p><span>Now, let's apply the cosine rule to the particular triangle we looked at a moment rul ago.</span></p>
<p><span>現在，讓我們將 cos 規則應用於我們剛才看到的特定三角形。</span></p>
<p><span>It's pretty straightforward to write down this particular relationship.</span></p>
<p><span>寫下這種特殊關係非常簡單。</span></p>
<p><span>We can isolate the term cos alpha which gives us the angle alpha that we're interested in.</span></p>
<p><span>我們可以分離出術語 cos α，它為我們提供了我們感興趣的角度 α。</span></p>
<p><span>And, it's defined in terms of the constant link lengths, A1 and A2 and the position of the end effector,x and y.</span></p>
<p><span>而且，它是根據恆定連桿長度 A1 和 A2 以及末端執行器的位置 x 和 y 定義的。</span></p>
<p><span>We can write this simple relationship between the angles alpha and Q2.</span></p>
<p><span>我們可以寫出角度 α 和 Q2 之間的這種簡單關係。</span></p>
<p><span>And, we know from the shape of the cosine function that cos of Q2 must be equal to negative of cos alpha.</span></p>
<p><span>而且，我們從餘弦函數的形狀知道，Q2 的 cos 必須等於 cos α 的負值。</span></p>
<p><span>This time, let's just write an expression for the cosine of the joined angle Q2.</span></p>
<p><span>這一次，讓我們為連接角 Q2 的cos寫一個表達式。</span></p>
<p><span>Now, we're going to draw yet another red triangle and we're going apply some simple trigonometry here.</span></p>
<p><span>現在，我們將繪製另一個紅色三角形，並在此處應用一些簡單的三角函數。</span></p>
<p><span>If we know Q2, then we know this length and this length of the red triangle.</span></p>
<p><span>如果我們知道 Q2，那麼我們就知道這個長度和這個紅色三角形的長度。</span></p>
<p><span>We can write this relationship for the sine of the joined angle Q2.</span></p>
<p><span>我們可以為連接角 Q2 的 sin 寫出這種關係。</span></p>
<p><span>Now, we can consider this bigger triangle whose angle is beta and this side length of the triangle is given here in blue.</span></p>
<p><span>現在，我們可以考慮這個更大的三角形，它的角是β，三角形的這條邊長在這裡用藍色給出。</span></p>
<p><span>And, the length of the other side of the triangle is this.</span></p>
<p><span>並且，三角形另一邊的長度是這個。</span></p>
<p><span>So, now we can write an expression for the angle beta in terms of these parameters here.</span></p>
<p><span></span>所以，現在我們可以在此處根據這些參數編寫角度 <span>β</span> 的表達式。</p>
<p><span>Going back to the red triangle that we drew earlier, we can establish a relationship between Q1 and the angle beta.</span></p>
<p><span>回到我們之前畫的紅色三角形，我們可以建立 Q1和角度 β 之間的關係。</span></p>
<p><span>Introduce yet another angle, this one gamma and we can write a relationship between the angle gamma and the tooltip coordinates x and y.</span></p>
<p><span>引入另一個角度，這個 ɣ，我們可以寫出角度 ɣ 和工具提示坐標 x 和 y 之間的關係。</span></p>
<p><span>Now, we can write a simple relationship between the angles that we've constructed, gamma and beta and the joined angle we're interested in which is Q1.</span></p>
<p><span></span>現在，我們可以在我們構建的角度 <span>ɣ </span>和 <span>β</span> 與我們感興趣的連接角度 Q1 之間寫出一個簡單的關係。</p>
<p><span>And, the total relationship looks something like this.</span></p>
<p><span>而且，整個關係看起來像這樣。</span></p>
<p><span>Quite a complex relationship, it gives us the angle of joined one, that's Q1 in terms of the end effector coordinates y and x, and a bunch of constants, a1 and a2, and it's also a function of the second joint angle, Q2.</span></p>
<p><span>相當複雜的關係，它為我們提供了連接的角度，即根據末端執行器坐標 y 和 x 的 Q1，以及一系列常量 a1 和 a2，它也是第二個關節角度 Q2 的函數。</span></p>
<p><span>So, let's summarize what it is that we have derived here.1</span></p>
<p><span>所以，讓我們總結一下我們在這裡得出的結論。1</span></p>
<p><span>We have an expression for the cosine of Q2 and we have an expression for Q1.</span></p>
<p><span>我們有 Q2 的 cos 表達式和 Q1 的表達式。</span></p>
<p><span>Now, the cosine function is symmetrical about 0.</span></p>
<p><span>現在，cos 函數關於 0 對稱。</span></p>
<p><span>So, if we know the value of the cosine of Q2, then there are two possible solutions, a positive angle and a negative angle</span></p>
<p><span>所以，如果我們知道 Q2 的 cos 值，那麼有兩種可能的解，一個正角和一個負角</span></p>
<p><span>We're going to explicitly choose the positive angle, which means that I can write this expression here.</span></p>
<p><span>我們將明確選擇正角，這意味著我可以在這裡寫這個表達式。</span></p>
<p><span>And now, we have what we call the inverse kinematic solution for this two-link robot.</span></p>
<p><span>現在，我們有了這個雙連桿機器人的逆運動學解決方案。</span></p>
<p><span>We have an expression for the two joined angles, Q1 and Q2 in terms of the end effector pose x and y, and a bunch of constants.</span></p>
<p><span>我們有兩個連接角 Q1 和 Q2 的表達式，根據末端執行器姿勢 x 和 y 以及一系列常數。</span></p>
<p><span>You notice that the two equations are not independent.</span></p>
<p><span>你注意到這兩個方程不是獨立的。</span></p>
<p><span>The equation for Q1, in fact, depends on the solution for Q2.</span></p>
<p><span>事實上，Q1 的方程取決於 Q2 的解。</span></p>
<p><span>In this case, Q2 is negative and we're going to write the solution for Q2 with a negative sign in front of the inverse cosine.</span></p>
<p><span>在這種情況下，Q2 是負數，我們將在反 cos 前用負號編寫 Q2 的解。</span></p>
<p><span>Now, we need to solve for Q1, so we're going to introduce this particular red triangle, the angle beta that we solved previously, and the angle gamma which is defined in terms of y and x.</span></p>
<p><span>現在，我們需要求解 Q1，因此我們將介紹這個特定的紅色三角形、我們之前求解的角度 <span>β</span> 以及根據 y 和 x 定義的角度 ɣ。</span></p>
<p><span>Now, we write a slightly different relationship between q1, gamma and beta, different to what we had before.</span></p>
<p><span>現在，我們在 q1、ɣ  和 β 之間寫出略有不同的關係，與我們之前的關係不同。</span></p>
<p><span>There’s a change of sign involved.</span></p>
<p><span>涉及到符號的變化。</span></p>
<p><span>Then, we can substitute all that previous equation and come up with this expression for q1.</span></p>
<p><span>然後，我們可以替換之前的所有等式，並得出 q1 的這個表達式。</span></p>
<p><span>Again, there is a change of sign here.</span></p>
<p><span>同樣，這裡的符號發生了變化。</span></p>
<p><span>Previously, this was a negative sign.</span></p>
<p><span>以前，這是一個負面信號。</span></p>
<p><span>And, here in summary form is the solution for the inverse kinematics of our two-link robot when it is in this particular configuration, where q2 is negative.</span></p>
<p><span>並且，這裡總結性地是我們的雙連桿機器人在這種特定配置下的逆運動學的解決方案，其中 q2 是負數。</span></p>
<p><span>Let’s compare the two solutions, the case where q2 is positive and the case where q2 is negative.</span></p>
<p><span>讓我們比較兩個解決方案，q2 為正的情況和 q2 為負的情況。</span></p>
<h3>part 2-joint</h3>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/eIZuz1XCd0w" title="YouTube video player" width="560"></iframe></p>
<p></p>
<p><span>Here we have the same two link robot as we just looked at but this time we're going tosolve it using an analytical approach , that is we're going to rely much more on algebra ,particular linear algebra rather than geometry .</span></p>
<p><span></span>在這裡，我們有與剛剛看到的相同的兩連桿機器人，但這次我們將使用分析方法來解決它，也就是說，我們將更多地依賴代數，特別是線性代數而不是幾何。</p>
<p><span>We have an expression E , which is the homogeneous transformation which represents the pose of the robots endefector and we looked at this in the last lecture , we can write the endefector pose as a sequence of elementary homogeneous transformations .</span></p>
<p><span></span>我們有一個表達式 E，它是表示機器人末端位姿的齊次變換，我們在上一課中看到了這一點，我們可以將末端位姿寫為一系列基本齊次變換。</p>
<p><span>A rotation by Q1 , a translation along the X direction by A1 , a rotation by Q2 and then a translation in the X direction by A2 .</span></p>
<p><span></span>Q1 旋轉，A1 沿 X 方向平移，Q2 旋轉，然後 A2 沿 X 方向平移。</p>
<p><span>If I expand this out , multiply all the transformations together , I get the expression shown here ; a three by three homogeneous transformation matrix representing the pose of the robot's endefector.</span></p>
<p><span></span>如果我將其展開，將所有變換相乘，就會得到此處所示的表達式； 一個三乘三的齊次變換矩陣，表示機器人的終結者的姿態</p>
<p><span>Now for this particular two link robot , we are only interested in the position of its endefector , it's X and Y co - ordinate and they are these two elements within the homogeneous transformation matrix , so I'm going to copy those out .</span></p>
<p><span>現在對於這個特殊的兩連桿機器人，我們只對它的末端位置感興趣，它是 X 和 Y 坐標，它們是齊次變換矩陣中的這兩個元素，所以我將把它們複製出來。</span></p>
<p><span>So here again is our expression for X and Y and what we're going to do is a fairly common trick , we're going to square and add these two equations and I get a relationship that looks like this .</span></p>
<p><span>所以這裡又是我們對 X 和 Y 的表達式，我們要做的是一個相當常見的技巧，我們要平方並添加這兩個方程，我得到一個看起來像這樣的關係。</span></p>
<p><span>Now I can solve for the joint angle Q2 in terms of the endefector pose X and Y and the robot's constants A1 and A2.</span></p>
<p>現在我可以根據末端姿勢 X 和 Y 以及機器人的常數 A1 和 A2 來求解關節角度 Q2。</p>
<p><span>Now what I'm going to do is apply the sum of angles identity .</span></p>
<p><span></span>現在我要做的是應用角度之和 。</p>
<p><span>I'm going to expand these terms, sine of Q1 plus Q2 or cos of Q1 plus Q2 and to make life a little bit easier, I'm going to make some substations, so where ever I had cos Q2, I'm going to write C2 and where ever I had sine Q2, I'm going to write S2.</span></p>
<p><span>我將擴展這些術語，Q1 的sin加 Q2 或 Q1 的 cos 加 Q2，為了讓生活更輕鬆一點，我將建造一些變電站，所以只要有 cos Q2，我就會去 寫 C2 並且在我有正弦 Q2 的地方，我要寫 S2。</span></p>
<p><span>It's a fairly common shorthand when people are looking at robot kinematic equations.</span></p>
<p><span></span>當人們查看機器人運動學方程時，這是一個相當常見的速記。</p>
<p><span>And here are the equations after making those substitutions.</span></p>
<p><span>這是進行這些替換後的方程式。</span></p>
<p><span>Looking at these two equations, I can see that they fall into a very well known form and for that form there is a very well known solution.</span></p>
<p><span>看看這兩個方程，我可以看到它們屬於一個眾所周知的形式，對於這種形式，有一個眾所周知的解決方案。</span></p>
<p><span>So I'm going to consider just one of the equations, the equation for Y and using our well known identity and it's solution, I can determine the values for the variables little a, little b and little c and once l've determined those, then I can just write down the solution for Q1, which x is the equivalent of theta in this particular case.</span></p>
<p>所以我將只考慮其中一個方程，Y 的方程，並使用我們眾所周知的恆等式和它的解，我可以確定變量小 a、小 b 和小 c 的值，一旦我確定了這些 ，然後我可以寫下 Q1 的解決方案，在這種特殊情況下，x 相當於 θ。</p>
<p><span>Here again is our expression for Q1, copied over from the previous slide and we may remember from earlier in our workings that we determined this particular relationship; X squared plus Y squared is equal to this particular complex expression.</span></p>
<p><span>這裡再次是我們對 Q1 的表達，從上一張幻燈片複製過來，我們可能還記得在我們工作的早期，我們確定了這種特殊關係； X 平方加 Y 平方等於這個特定的複雜表達式。</span></p>
<p><span>So I can substitute that in and do some simplification and I end up with this slightly less complex expression for Q1.</span></p>
<p><span>因此，我可以將其替換並進行一些簡化，最終得到 Q1 的這個稍微不那麼複雜的表達式。</span></p>
<p><span>And it is the same expression that I got following the geometric approach in the previous section.</span></p>
<p><span>這與我在上一節中遵循幾何方法得到的表達式相同。</span></p>
<p><span></span></p>
<h2>week16</h2>
<h3>Fossil</h3>
<p>step1  download <a href="https://fossil-scm.org/home/uv/download.html"> Fossil</a> 存到 Y 槽</p>
<p>step2 打指令 </p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">1. G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2\data\tmp\W16\fossil&gt; 
2. fossil clone https://40823111@fossil.kmol.info/u/cda cda.fossil
3.mkdir cda
4.G:\cd2021\kmol2021_spring_v2\kmol2021_spring_v2\data\tmp\W16\fossil\wd\cda&gt;
5.fossil open ./../../cda.fossil
6. 確定有fossil的檔案 然後把倉儲的資料cd2021裡面的東西全部複製到cda的目錄下
7.fossil add .
8.fossil commit -m"檔案名稱 "
9.確定推上去就成功了
10. 開啟網頁 https://fossil.kmol.info/u/cda/doc/trunk/index.html
</pre>
<p><img alt="" height="292" src="/images/cmd_0ikTvGyyWk.png" width="571"/></p>
<p><img alt="" height="291" src="/images/cmd_6WMKL3fgy4.png" width="569"/></p>
<h3>w16</h3>
<h4>MTB_robot 的取放方塊流程規劃 (Process Planning):</h4>
<h4>1. Onshape 零組件繪製 (20%)</h4>
<p>零組件必須在<span> </span><a href="https://www.onshape.com/">Onshape</a><span> </span>繪圖, 並提供可公開分享之零組件連結於頁面及回報區中.</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/P2mkUbuAjSk" title="YouTube video player" width="560"></iframe></p>
<h4>2. 建立 CoppeliaSim 4.1.0 MTB robot 場景 (20%)</h4>
<p>請以自行繪製之零件輸入 CoppeliaSim 後, 組合為 MTB robot 模型, 並利用 Leo Editor 以 require 導入 Lua 程式運作, 分別控制各軸轉動示範, 所完成的所有檔案請存入 W16_exam 後壓縮為 W16_exam.7z 後送至個人 @gm 帳號下的 Google Drive 後將連結設為任何人皆可下載, 並將連結與操作嵌入影片放在 W16 頁面與回報區中 .</p>
<h4>3. 手臂末端加入 components-gripper-suction pad 吸盤 (20%)</h4>
<p>請接續上述 MTB robot, 在其末端接上 force sensor 後接上標準 suction pad 後, 分別導入 W15 週線上課程之鍵盤控制程式後, 拍攝影片示範 W15 線上課程中之操作與示範過程.</p>
<h4>4. 逆向運動學函式 (20%)</h4>
<p>請根據 W15 線上課程內容之 Inverse Kinematics 方程式 (<a href="https://www.youtube.com/watch?v=IKOGwoJ2HLk&amp;t=35s">影片1</a><span> </span>或<a href="https://www.youtube.com/watch?v=eIZuz1XCd0w&amp;t=183s">影片2</a>), 以程式指定方塊取放之兩個位置 - (0.2, 0.7, 0.05) 與 (-0.3, -0.55, 0.05), 以前述 Leo Editor Lua 程式編寫方法, 分別採鍵盤控制與程式迴圈方式執行 W15 兩個指定位置之方塊取放.</p>
<h4>5. Python remote API 逆向運動學函式 (20%)</h4>
<p>請利用 Python remote API 程式重現以迴圈方式執行 W15 兩個指定位置之方塊取放.</p>
<p></p>
<h1>W16</h1>
<h4>(1) Onshape 繪製出機械手臂零件</h4>
<p>     圖檔連結: <a href="https://cad.onshape.com/documents/9e9721534d87945d078e4850/w/464ee86b33b85ab5e7454fd3/e/8103231299b57ea049310546">請點我</a></p>
<p></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/P2mkUbuAjSk" title="YouTube video player" width="560"></iframe></p>
<h4>(2) 建立 CoppeliaSim 4.1.0 MTB robot 場景</h4>
<p>檔案下載: 請點我</p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/MTB_passive.ttt">MTB_passive.ttt</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/MTB.leo">MTB.leo</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/MTB.lua">MTB.lua</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/suctionpad_w14.lua">suctionpad_w14.lua</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/qVddNGQSfX4" title="YouTube video player" width="560"></iframe></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    -- do some initialization here
    joint_hanld1=sim.getObjectHandle('joint1')
    joint_hanld2=sim.getObjectHandle('joint2')
    joint_hanld3=sim.getObjectHandle('joint3')
    joint_hanld4=sim.getObjectHandle('joint4')
    suctionPad=sim.getObjectHandle('suctionPad')
    angle=math.pi/180
    angle1=0
    angle2=0
    d=0
    a1=0.8
    a2=0.8
    x=0.2
    y=0.7
end

function sysCall_actuation()
    -- put your actuation code here
    message, auxiliaryData=sim.getSimulatorMessage()
        while message ~= -1 do
            key=auxiliaryData[1]
            sim.addStatusbarMessage('????? key:'..key)
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==100) then --d
                    -- if key a pressed joint1 left
                    angle1=angle1+angle
                    sim.setJointPosition(joint_hanld1,angle1)
                end -- if d
                if (auxiliaryData[1]==97) then --a 
                    -- if key d pressed joint1 right
                    angle1=angle1-angle
                    sim.setJointPosition(joint_hanld1,angle1)
                end -- if a
                if (auxiliaryData[1]==101) then --e
                    -- if key e pressed joint2 left
                    angle2=angle2+angle
                    sim.setJointPosition(joint_hanld2,angle2)
                end -- if d
                if (auxiliaryData[1]==113) then --q 
                    -- if key q pressed joint2 right
                    angle2=angle2-angle
                    sim.setJointPosition(joint_hanld2,angle2)
                end -- if a
                message, auxiliaryData=sim.getSimulatorMessage()
                if (auxiliaryData[1]==56) then --8
                    -- if key 8 pressed suctionpad up and active=ture
                    d=d-0.05
                    sim.setJointPosition(joint_hanld3,d)
                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','ture')
                end -- if 8
                if (auxiliaryData[1]==53) then --5
                    -- if key 8 pressed suctionpad down 
                    sim.setJointPosition(joint_hanld3,0.084)
                end -- if 5
                if (auxiliaryData[1]==115) then --s
                    -- if key s pressed active=false
                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','false')
                end -- if 5
            end
        end  
end
</pre>
<p></p>
<h4>(3) 手臂末端加入 components-gripper-suction pad 吸盤<span> </span></h4>
<p><span></span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/IlvvEVKlnmQ" title="YouTube video player" width="560"></iframe></p>
<p>這是主程式</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init()
    -- do some initialization here
    joint_hanld1=sim.getObjectHandle('joint1')
    joint_hanld2=sim.getObjectHandle('joint2')
    joint_hanld3=sim.getObjectHandle('joint3')
    joint_hanld4=sim.getObjectHandle('joint4')
    suctionPad=sim.getObjectHandle('suctionPad')
    angle=math.pi/180
    angle1=0
    angle2=0
    d=0
    a1=0.8
    a2=0.8
    x=0.2
    y=0.7
end

function sysCall_actuation()
    -- put your actuation code here
    message, auxiliaryData=sim.getSimulatorMessage()
        while message ~= -1 do
            key=auxiliaryData[1]
            sim.addStatusbarMessage('????? key:'..key)
            if (message==sim.message_keypress) then
                if (auxiliaryData[1]==100) then --d
                    -- if key a pressed joint1 left
                    angle1=angle1+angle
                    sim.setJointPosition(joint_hanld1,angle1)
                end -- if d
                if (auxiliaryData[1]==97) then --a 
                    -- if key d pressed joint1 right
                    angle1=angle1-angle
                    sim.setJointPosition(joint_hanld1,angle1)
                end -- if a
                if (auxiliaryData[1]==101) then --e
                    -- if key e pressed joint2 left
                    angle2=angle2+angle
                    sim.setJointPosition(joint_hanld2,angle2)
                end -- if d
                if (auxiliaryData[1]==113) then --q 
                    -- if key q pressed joint2 right
                    angle2=angle2-angle
                    sim.setJointPosition(joint_hanld2,angle2)
                end -- if a
                if (auxiliaryData[1]==56) then --8
                    -- if key 8 pressed suctionpad up and active=ture
                    d=d-0.05
                    sim.setJointPosition(joint_hanld3,d)
                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','ture')
                end -- if 8
                if (auxiliaryData[1]==53) then --5
                    -- if key 8 pressed suctionpad down 
                    sim.setJointPosition(joint_hanld3,0.084)
                end -- if 5
                if (auxiliaryData[1]==115) then --s
                    -- if key s pressed active=false
                    sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','false')
                end -- if 5
                message, auxiliaryData=sim.getSimulatorMessage()
            end
        end  
end

</pre>
<p>這是吸盤程式</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init() 
    s=sim.getObjectHandle('suctionPadSensor')
    l=sim.getObjectHandle('suctionPadLoopClosureDummy1')
    l2=sim.getObjectHandle('suctionPadLoopClosureDummy2')
    b=sim.getObjectHandle('suctionPad')
    suctionPadLink=sim.getObjectHandle('suctionPadLink')

    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,'infiniteStrength')
    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,'maxPullForce')
    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,'maxShearForce')
    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,'maxPeelTorque')

    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
end

function sysCall_cleanup() 
--[[
    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
]]--
end 

function sysCall_sensing() 
    parent=sim.getObjectParent(l)
    if (sim.getScriptSimulationParameter(sim.handle_self,'active')==false) then
        if (parent~=b) then
            sim.setLinkDummy(l,-1)
            sim.setObjectParent(l,b,true)
            m=sim.getObjectMatrix(l2,-1)
            sim.setObjectMatrix(l,-1,m)
        end
    else
        if (parent==b) then
            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)
            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.
            -- But "sim.checkProximitySensor" or similar will work (they don't check the "detectable" flags), but we have to go through all shape objects!
            index=0
            while true do
                shape=sim.getObjects(index,sim.object_shape_type)
                if (shape==-1) then
                    break
                end
                if (shape~=b) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(s,shape)==1) then
                    -- Ok, we found a respondable shape that was detected
                    -- We connect to that shape:
                    -- Make sure the two dummies are initially coincident:
                    sim.setObjectParent(l,b,true)
                    m=sim.getObjectMatrix(l2,-1)
                    sim.setObjectMatrix(l,-1,m)
                    -- Do the connection:
                    sim.setObjectParent(l,shape,true)
                    sim.setLinkDummy(l,l2)
                    break
                end
                index=index+1
            end
        else
            -- Here we have an object attached
            if (infiniteStrength==false) then
                -- We might have to conditionally beak it apart!
                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)
                if (result&gt;0) then
                    breakIt=false
                    if (force[3]&gt;maxPullForce) then breakIt=true end
                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])
                    if (sf&gt;maxShearForce) then breakIt=true end
                    if (torque[1]&gt;maxPeelTorque) then breakIt=true end
                    if (torque[2]&gt;maxPeelTorque) then breakIt=true end
                    if (breakIt) then
                        -- We break the link:
                        sim.setLinkDummy(l,-1)
                        sim.setObjectParent(l,b,true)
                        m=sim.getObjectMatrix(l2,-1)
                        sim.setObjectMatrix(l,-1,m)
                    end
                end
            end
        end
    end
    if (sim.getSimulationState()==sim.simulation_advancing_lastbeforestop) then
        sim.setLinkDummy(l,-1)
        sim.setObjectParent(l,b,true)
        m=sim.getObjectMatrix(l2,-1)
        sim.setObjectMatrix(l,-1,m)
    end
end 
</pre>
<p><span></span></p>
<h4>(4) 逆向運動學函式<span> </span></h4>
<p><span>檔案下載</span></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/MTB_force%20mode.ttt">MTB_force mode.ttt</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/mtb_force%20mode.leo">mtb_force mode.leo</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/MTB_threadmain.lua">MTB_threadmain.lua</a></p>
<p><a href="https://github.com/40823111/cd2021/blob/main/remote%20api/suctionpad_w14.lua">suctionpad_w14.lua</a></p>
<p><span></span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/21BpBzN5MFc" title="YouTube video player" width="560"></iframe></p>
<p><span></span></p>
<p>這是主程式</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_threadmain()
    -- do some initialization here
    joint_hanld1=sim.getObjectHandle('joint1')
    joint_hanld2=sim.getObjectHandle('joint2')
    joint_hanld3=sim.getObjectHandle('joint3')
    suctionPad=sim.getObjectHandle('suctionPad')
    angle=180/math.pi
    angle1=math.pi/180
    d=0
    a1=0.8
    a2=0.8
    x=0.7
    y=0.2
    print(a)
    function round(x, n)
    n = math.pow(10, n or 0)
    x = x * n
    if x &gt;= 0 then x = math.floor(x + 0.5) else x = math.ceil(x - 0.5) end
    return x / n
end
 
-- radian to degree
deg = 180/math.pi
-- link 1 length
a1 = 0.8
-- link 2 length
a2 = 0.8
-- derivated based upon https://www.youtube.com/watch?v=IKOGwoJ2HLk&amp;t=311s
function ik(x, y)
    -- (x, y) need to be located inside the circle with radius a1+a2
    if (x^2 + y^2) &lt;= (a1+ a2)^2 then
        q2 = -math.acos((x^2+y^2-a1^2-a2^2)/(2*a1*a2))
        q1 = math.atan2(y, x) + math.atan2((a2*math.sin(q2)), (a1+a2*math.cos(q2)))
        return {round(q1*deg, 4), round(q2*deg, 4)}
    else
        print("Over range!")
    end
end
 
theta = ik(0.7, 0.2)
 
print(theta[1], theta[2])
            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)
            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)
            sim.wait(3)
    while(true)
        do  
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,0.06)
            sim.wait(3)
            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','ture')
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,-0.06)
            sim.wait(3)
            theta = ik(-0.55, -0.3)
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)
            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)
            sim.wait(10)
            sim.setJointTargetPosition(joint_hanld3,0.06)
            sim.wait(3)
            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','false')
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,-0.06)
            sim.wait(3)
            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','ture')
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,0.06)
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,-0.06)
            sim.wait(3)
            theta = ik(0.7, 0.2)
            sim.setJointTargetPosition(joint_hanld1,-theta[1]*angle1)
            sim.setJointTargetPosition(joint_hanld2,theta[2]*angle1)
            sim.wait(10)
            sim.setJointTargetPosition(joint_hanld3,0.06)
            sim.wait(3)
            sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad),'active','false')
            sim.wait(3)
            sim.setJointTargetPosition(joint_hanld3,-0.06)
    end   
end
</pre>
<p>這是吸盤程式</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">function sysCall_init() 
    s=sim.getObjectHandle('suctionPadSensor')
    l=sim.getObjectHandle('suctionPadLoopClosureDummy1')
    l2=sim.getObjectHandle('suctionPadLoopClosureDummy2')
    b=sim.getObjectHandle('suctionPad')
    suctionPadLink=sim.getObjectHandle('suctionPadLink')

    infiniteStrength=sim.getScriptSimulationParameter(sim.handle_self,'infiniteStrength')
    maxPullForce=sim.getScriptSimulationParameter(sim.handle_self,'maxPullForce')
    maxShearForce=sim.getScriptSimulationParameter(sim.handle_self,'maxShearForce')
    maxPeelTorque=sim.getScriptSimulationParameter(sim.handle_self,'maxPeelTorque')

    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
end

function sysCall_cleanup() 
--[[
    sim.setLinkDummy(l,-1)
    sim.setObjectParent(l,b,true)
    m=sim.getObjectMatrix(l2,-1)
    sim.setObjectMatrix(l,-1,m)
]]--
end 

function sysCall_sensing() 
    parent=sim.getObjectParent(l)
    if (sim.getScriptSimulationParameter(sim.handle_self,'active')==false) then
        if (parent~=b) then
            sim.setLinkDummy(l,-1)
            sim.setObjectParent(l,b,true)
            m=sim.getObjectMatrix(l2,-1)
            sim.setObjectMatrix(l,-1,m)
        end
    else
        if (parent==b) then
            -- Here we want to detect a respondable shape, and then connect to it with a force sensor (via a loop closure dummy dummy link)
            -- However most respondable shapes are set to "non-detectable", so "sim.readProximitySensor" or similar will not work.
            -- But "sim.checkProximitySensor" or similar will work (they don't check the "detectable" flags), but we have to go through all shape objects!
            index=0
            while true do
                shape=sim.getObjects(index,sim.object_shape_type)
                if (shape==-1) then
                    break
                end
                if (shape~=b) and (sim.getObjectInt32Parameter(shape,sim.shapeintparam_respondable)~=0) and (sim.checkProximitySensor(s,shape)==1) then
                    -- Ok, we found a respondable shape that was detected
                    -- We connect to that shape:
                    -- Make sure the two dummies are initially coincident:
                    sim.setObjectParent(l,b,true)
                    m=sim.getObjectMatrix(l2,-1)
                    sim.setObjectMatrix(l,-1,m)
                    -- Do the connection:
                    sim.setObjectParent(l,shape,true)
                    sim.setLinkDummy(l,l2)
                    break
                end
                index=index+1
            end
        else
            -- Here we have an object attached
            if (infiniteStrength==false) then
                -- We might have to conditionally beak it apart!
                result,force,torque=sim.readForceSensor(suctionPadLink) -- Here we read the median value out of 5 values (check the force sensor prop. dialog)
                if (result&gt;0) then
                    breakIt=false
                    if (force[3]&gt;maxPullForce) then breakIt=true end
                    sf=math.sqrt(force[1]*force[1]+force[2]*force[2])
                    if (sf&gt;maxShearForce) then breakIt=true end
                    if (torque[1]&gt;maxPeelTorque) then breakIt=true end
                    if (torque[2]&gt;maxPeelTorque) then breakIt=true end
                    if (breakIt) then
                        -- We break the link:
                        sim.setLinkDummy(l,-1)
                        sim.setObjectParent(l,b,true)
                        m=sim.getObjectMatrix(l2,-1)
                        sim.setObjectMatrix(l,-1,m)
                    end
                end
            end
        end
    end
    if (sim.getSimulationState()==sim.simulation_advancing_lastbeforestop) then
        sim.setLinkDummy(l,-1)
        sim.setObjectParent(l,b,true)
        m=sim.getObjectMatrix(l2,-1)
        sim.setObjectMatrix(l,-1,m)
    end
end 
</pre>
<h4>(5) Python remote API 逆向運動學函式</h4>
<p><span>檔案下載</span></p>
<p><a href='/get_page/week17/"https:/github.com/40823111/cd2021/blob/main/remote%20api/MTB_api.ttt&lt;/a'>MTB_api.ttt</a></p>
<p><a href='/get_page/week17/"https:/github.com/40823111/cd2021/blob/main/remote%20api/MTB_api.py&lt;/a'>MTB_api.py</a></p>
<p><a href='/get_page/week17/"https:/github.com/40823111/cd2021/blob/main/remote%20api/remoteApi.dll&lt;/a'>remoteApi.dll</a></p>
<p><a href='/get_page/week17/"https:/github.com/40823111/cd2021/blob/main/remote%20api/sim.py&lt;/a'>sim.py</a></p>
<p><a href='/get_page/week17/"https:/github.com/40823111/cd2021/blob/main/remote%20api/simConst.py&lt;/a'>simConst.py</a></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/h8g9JENWBh8" title="YouTube video player" width="560"></iframe></p>
<p></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># File created by Thibaut Royer, Epitech school
# thibaut1.royer@epitech.eu
# It intends to be an example program for the "Two wheels, one arm" educative project.
import sim as vrep
import math
import random
import time
import keyboard


print ('Start')

# Close eventual old connections
vrep.simxFinish(-1)
# Connect to V-REP remote server
clientID = vrep.simxStart('127.0.0.1', 19999,, True, True, 5000, 5)

if clientID != -1:
    print ('Connected to remote API server')
    
    res = vrep.simxAddStatusbarMessage(
        clientID, "40823111",
        vrep.simx_opmode_oneshot)
    if res not in (vrep.simx_return_ok, vrep.simx_return_novalue_flag):
        print("Could not add a message to the status bar.")

    
    opmode = vrep.simx_opmode_oneshot_wait
    angle1=math.pi/180
    
    # radian to degree
    deg = 180/math.pi
    # link 1 length
    a1 = 0.8
    # link 2 length
    a2 = 0.8
    # derivated based up https://www.youtube.com/watch?v=IKOGwoJ2HLk&amp;t=311s
     
    def ik(x, y):
        # (x, y)  need to be located inside the circle with radius a1+a2
        if (x**2 + y**2) &lt;= (a1+ a2)**2:
            q2 = -math.acos((x**2+y**2-a1**2-a2**2)/(2*a1*a2))
            q1 = math.atan2(y, x) + math.atan2((a2*math.sin(q2)), (a1+a2*math.cos(q2)))
            # The decimal point of number is rounded to the 4th place
            return [round(q1*deg, 4), round(q2*deg, 4)]
        else:
            print("Over range!")
            # end the script execution
 
    theta = ik(0.7, 0.2)
 
    print(theta[0], theta[1])
    
    vrep.simxStartSimulation(clientID, opmode)
    ret,joint_hanld1=vrep.simxGetObjectHandle(clientID,"joint1",opmode)
    ret,joint_hanld2=vrep.simxGetObjectHandle(clientID,"joint2",opmode)
    ret,joint_hanld3=vrep.simxGetObjectHandle(clientID,"joint3",opmode)
    ret,suctionPad=vrep.simxGetObjectHandle(clientID,"suctionPad",opmode)
    vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)
    vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)
    time.sleep(0.5)
    while True:
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)
            time.sleep(0.5)
            vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)
            time.sleep(0.5)
            theta = ik(-0.55, -0.3)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)
            time.sleep(2)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)
            time.sleep(0.5)
            vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)
            time.sleep(0.5)
            vrep.simxSetIntegerSignal(clientID,"pad_switch",1,opmode)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)
            time.sleep(0.5)
            theta = ik(0.7, 0.2)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld1,-theta[0]*angle1,opmode)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld2,theta[1]*angle1,opmode)
            time.sleep(2)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,0.06,opmode)
            time.sleep(0.5)
            vrep.simxSetIntegerSignal(clientID,"pad_switch",0,opmode)
            time.sleep(0.5)
            vrep.simxSetJointTargetPosition(clientID,joint_hanld3,-0.06,opmode)
    end
        
else:
    print ('Failed connecting to remote API server')
    print ('End')
</pre>
<h3><span>心得</span></h3>
<p>心得: 這學期採取分組，比較像外面上班一起分工合作，共同完成一項作業，這是一項非常有效率且不會太累的模式，這學期教得像Remote Api 模擬自走車，自己設路徑給他走甚至是機械手臂都是以前沒碰過，還有像端遙控(remote api)有點不可思議，雖然一開始很難，但當自己成功做出來時會覺得非常有成就感，感覺很帥，沒想到一些簡單的網路程式，竟然可以帶給我無法想像的境界，含有老師的觀念方向，都讓我有一些新的想法，明知不可為而偏為之，但是如果不去試，人類怎麼會進步，我又怎麼知道自己的極限到底在哪裡</p>
<p></p>